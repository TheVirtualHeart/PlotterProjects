---
title: hopf2a
plot: true
---

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>hopf2a</title>
	<script src="../node_modules/plotter/plotter.dev.js"></script>
	<script>
	var app; //the plotter object
	var lineB; //the line to iterate against
	var cutoff = 40; //the x value at which to cut off for a conduction block
	var points = []; //points for the scatter plot
	
	//initialises the app and creates the graphs
	function init()
	{
		app = createPlotter(document.getElementById("plot"));
		var settings =
		{
			domain: new Point(0, 4000),
			range: new Point(0, 300),
			pixelPerUnit: new Point(1, 1),
			unitPerTick: new Point(50, 50),
			labelFrequency: new Point(2, 2),
			xAxis: "DI (ms)",
			yAxis: "APD (ms)"
		};
		app.newPlot(settings, "graph"); //creates the main graph
		
		settings =
		{
			offset: new Point(0, 380),
			domain: new Point(250, 5000),
			range: new Point(0, 300),
			pixelPerUnit: new Point(1.5, 1),
			unitPerTick: new Point(50, 50),
			labelFrequency: new Point(2, 2),
			xAxis: "Period (ms)",
			yAxis: "APD (ms)"
		}
		app.newPlot(settings, "scatter"); //creates the scatter plot
		
		setInterval(update, 1000/60); //update once per frame at a desired 60fps
	}
	
	window.onload = init;
	
	//is optimally called once per frame at 60fps
	function update()
	{
		console.log("h");
		app.selectPlot("graph"); //this clears the graph plot and gets it ready for interaction
		
		app.plotSlope(app.mouse.down, -1); //this draws the black line where you clicked down
		app.plotFunction(curve, true, .01, cutoff); //this draws the curve starting at the cutoff
		
		app.ctx.strokeStyle = "#0000FF"; //blue
		if (app.mouse.isDown) //if you are dragging the mouse
			lineB = app.plotSlope(app.mouse.move, -1); //set the line to where the mouse is and store it
		else if (lineB != undefined) //else if there has been a line made, keep drawing it
			app.plotLine(lineB.a, lineB.b);
		
		if (lineB != undefined) //if the user has clicked down and dragged their mouse
		{
			app.ctx.strokeStyle = "#FF0000"; //red
			var pointsBuffer = hop(app.mouse.down, 100, 2); //do the hopf bifurcation iteration
			app.plotPoly(pointsBuffer); //plot the points from the iteration
		
			app.selectPlot("scatter"); //this clears the scatter plot and gets it ready for interaction
			
			if (pointsBuffer[pointsBuffer.length - 1].x >= cutoff) //cheeky way of checking if a conduction block has occurred
			{
				//this offsetSample value ensures that the following checks are applied to points on the curve from the pointsBuffer
				var offsetSample = curve(pointsBuffer[pointsBuffer.length - 1].x) == pointsBuffer[pointsBuffer.length - 1].y ? 0 : 1;
				//these two points are the last two points on the curve in the hopf bifurcation iteration
				var newPointA = pointsBuffer[pointsBuffer.length - (3 + offsetSample)];
				var newPointB = pointsBuffer[pointsBuffer.length - (1 + offsetSample)];
				//this transforms the point to be ready for the scatter plot values
				newPointA = new Point(newPointA.x + newPointB.y, newPointA.y);
				newPointB = new Point(newPointB.x + newPointA.y, newPointB.y)
				
				//if the point is on the plot and it has not been plotted before, push it to the array
				//these checks are done to ensure optimization and zero duplicate entries
				if (!isPointPlotted(newPointA) && app.pointOnPlot(newPointA, "scatter"))
					points.push(newPointA);
				if (!isPointPlotted(newPointB) && app.pointOnPlot(newPointB, "scatter"))
					points.push(newPointB);
			}
		}
		
		//plot the points on the scatter plot
		for (var point in points)
			app.plotPoint(points[point]);
			
		app.ctx.strokeStyle = "#FF0000"; //red
		//highlight the currently plotted point if it is defined
		if (newPointA != undefined)
			app.plotPoint(newPointA, 3, false);
		if (newPointB != undefined)
			app.plotPoint(newPointB, 3, false);
	}
	
	//the curve that is iterated against
	function curve(x)
	{
		var a0 = -647.8;
		var a1 = 34.1;
		var a2 = -0.567;
		var a3 = 0.003349;
		var a4 = 0;
		
		if(x > 65 && x <= 90)
		{
			a0 = 837.8;
			a1 = -34.16;
			a2 = 0.4834;
			a3 = -0.002065;
		}
		else if(x > 90 && x <= 105.7)
		{
			a0 = 565.7;
			a1 = -21.34;
			a2 = 0.2987;
			a3 = -0.001223;
		}
		else if(x > 105.7)
		{
			a0 = 134.1;
			a1 = 1.041;
			a2 = -0.004848;
			a3 = 1.242e-05;
			a4 = -1.292e-08;
		}
		
		if(x < 88)
			return a0 + a1 * x + a2 * Math.pow(x,2) + a3 * Math.pow(x,3) + a4 * Math.pow(x,4);
		else
			return 255.377 * (1 - 0.41592 * Math.exp(-x / 149.173) - 298.2 * Math.exp(-x / 11.1681));
	}
	
	//this algorithm produces a hopf bifurcation at point p, depth amout of iterations
	function hop(p, depth)
	{
		var points = [new Point(p.x, p.y)] //the points generated by the hops
		var x = p.x;
		var y = p.y;
		
		for (var i = 0; i < depth; i++)
		{
			if (i & 1) //if odd
				x = lineB.point.y - y + lineB.point.x; //find x on -1 slope given last y
			else
				y = curve(x); //find y on curve given last x
			p = new Point(x, y); //store x and y as a new point
			points.push(p); //and push it into the array
			
			if (x < cutoff) //if a cutoff occurs, render the text on screen and break
			{
				app.ctx.font = "32px Helvetica";
				app.ctx.textAlign = "center";
				app.ctx.textBaseline = "middle";
				app.plotText("Conduction Block");
				break;
			}
		}
		
		return points; //return the points so that they can be rendered by plotPoly and/or re-used
	}
	
	//returns true if the point is already in the points array
	function isPointPlotted(p)
	{
		for (var i = 0; i < points.length; i++)
			if (p.x == points[i].x && p.y == points[i].y) //if the points share the same values
				return true;
		return false; //this is only reached if no point is found
	}
	</script>
</head>
<body>
	<div id="app">
		<canvas id="plot">This graph requires HTML5 canvas support, sorry!</canvas>
	</div>
</body>
</html>